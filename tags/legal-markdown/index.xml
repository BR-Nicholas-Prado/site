<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>underWater desert Blogging</title><link>https://caseykuhlman.com/</link><description>A Site About Resilience and Authoritarianism</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>casey@caseykuhlman.com (Casey Kuhlman)</managingEditor><webMaster>casey@caseykuhlman.com (Casey Kuhlman)</webMaster><copyright>All Content Licensed CC BY-NC-SA 4.0</copyright><lastBuildDate>Thu, 19 Dec 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://caseykuhlman.com/tags/legal-markdown/index.xml" rel="self" type="application/rss+xml"/><item><title>Git Based Negotiations - A Concept Piece</title><link>https://caseykuhlman.com/muniments/2013/2013-12-19-git-based-negotiations/</link><pubDate>Thu, 19 Dec 2013 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2013/2013-12-19-git-based-negotiations/</guid><description>&lt;p>Yesterday, I was having a conversation with a fellow &lt;a href="https://github.com/dpp/lawyersongithub">github lawyer&lt;/a> about git-based contract negotiations (gitgotiations&amp;hellip;?). Indeed, this has been on my mind for a while and was one of my motivating, longer term reasons for thinking that some kind of text-based &lt;a href="https://github.com/compleatang/legal-markdown">legal document format&lt;/a> was necessary.&lt;/p>
&lt;p>For the production of many documents, lawyers need not worry too much about what goes into repos as it is only the final version of the document which is shared publicly. That final document is likely to be a redacted .pdf so there is no need to worry about the history of the memo, filing, or whatnot.&lt;/p>
&lt;p>But, if lawyers were to utilize git for negotiation they would need to be careful about what their commit history looked like, because opening up one's history of thinking about a document could reveal too much to another party one was seeking to contract with. Although I'm generally all for openness there is a time and a place for that, and transaction negotiation is not the time and place to necessarily be open and transparent.&lt;/p>
&lt;p>This piece is meant simply to think through a concept that outlines my thoughts on how a negotiation backed by git &lt;em>could&lt;/em> work. Of course, this would need to be tested to determine its feasibility, the problems and holes it may present to practitioners, etc. As a sidenote, if anyone is interested in conducting some mock negotiations on GitHub to try to identify where the sticking points are in this, I'm 100% game.&lt;/p>
&lt;h2 id="scenario">Scenario&lt;/h2>
&lt;p>Two parties are negotiating a contractual relationship. Both parties have lawyers who understand how git works and use text-based documents to draft their contracts. In theory, this would work with Word based documents with something like &lt;a href="http://vitus.wagner.pp.ru/software/catdoc">catdoc&lt;/a> and some gitattribute &lt;a href="http://git-scm.com/book/en/Customizing-Git-Git-Attributes">magic&lt;/a>, but those are still problematic to diff and people would already use Word's track changes for worse or better.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The party initiating the contract, Party A, speaks to its lawyers who modify one of their templates to reflect the preliminary terms and parties which the Party A passes along to its lawyers. That portion is practice, but after that is when this concept begins to differ from current practice.&lt;/p>
&lt;p>After Party A's lawyers develop the Draft 0 of the proposed contract, they then open their repository for this matter to opposing counsel. When they open this repository, however, they only give allow opposing counsel to access one branch. This branch could be called &amp;ldquo;external,&amp;rdquo; but because of git defaults it is likely to be the &amp;ldquo;master&amp;rdquo; branch. For the purposes of this piece I will refer to the &amp;ldquo;master&amp;rdquo; branch as the &amp;ldquo;external&amp;rdquo; branch, but of course they could be named whatever make sense to the counsel in question. The reason for only allowing opposing counsel to see one of the two branches is to hide the internal work from opposing counsel. Another way that Party A's lawyers could do this is using a submodule, but theoretically using submodules rather than branches seems more complicated to me.&lt;/p>
&lt;p>Once Party A's lawyers open up the repository to Party B's lawyers, then Party B's lawyers make their own internal branch and perform their review. Then the negotiation takes place via a series of pull requests between the parties until the master branches of both parties have no differences. At that point, the parties have agreed on all the terms of the contract and it can be signed by the parties.&lt;/p>
&lt;h2 id="steps-prior-to-negotiation----party-a">Steps Prior to Negotiation &amp;ndash; Party A&lt;/h2>
&lt;p>All of Party A's work prior to opening up the repo to Party B's lawyers should be encapsulated in a branch which will be restricted to that Party and its lawyers only and will not be opened to opposing counsel. This will keep internal discussions or changes that may reveal the Party's position in a branch which opposing counsel cannot see. Git offers (at least) three commands which could be used in this workflow.&lt;/p>
&lt;p>The first command is &lt;code>git checkout master &amp;amp;&amp;amp; git merge --squash internal&lt;/code>. What this command will do is to first switch to the master branch and then merge in the work from the internal branch. The most important part of the command is the &lt;code>--squash&lt;/code> switch. When git merges the changes from the internal branch into the master branch, counsel will not want all of the commits to be shown, but what it will want is the final document (likely with comments redacted if they have been put into the document along the way) &amp;lsquo;squashed&amp;rsquo; down. Without the &lt;code>--squash&lt;/code> switch, then the merge would bring in all of the commits during the workflow. That is very unlikely to be what Party A's lawyers want to do as it will very likely reveal some positioning or other things that the counter Party's lawyers could use in their negotiation.&lt;/p>
&lt;p>The second command, and the one that I would personally start with, is &lt;code>git checkout master &amp;amp;&amp;amp; git rebase --interactive internal&lt;/code>. This command is a more powerful version of the &lt;code>git merge --squash&lt;/code> command. Rebasing is slightly different than merging, but for the purposes of this piece, those are largely immaterial. If you want to see a deeper discussion of rebasing, Scott Chacon's &lt;a href="http://git-scm.com/book/en/Git-Branching-Rebasing">Git book&lt;/a> is the best place to start. What this command will do is to bring up an editor so that the lawyer rebasing the internal branch onto the master branch will be able to pick and choose which commits are brought into the rebase and which are not. In addition, with an interactive rebase such as this, one can also squash down the commits as with &lt;code>merge --squash&lt;/code> command.&lt;/p>
&lt;p>The third command, and probably the least optimal command to use at this stage in the process is &lt;code>git checkout master &amp;amp;&amp;amp; git cherry-pick --no-commit ..internal &amp;amp;&amp;amp; git commit&lt;/code>. &lt;a href="http://git-scm.com/docs/git-cherry-pick">Cherry-picking commits&lt;/a> is, to be honest, not exactly what should happen at this point. Cherry-picking commits is probably more likely to be used later in the process but it &lt;em>could&lt;/em> potentially be used at this point. Fundamentally, what the command does is to switch to the master branch and to bring in all of the changes from the internal branch which are not currently in the master branch. The key with this command is the &lt;code>--no-commit&lt;/code> switch. This tells git to apply the changes from the internal branch but to not make a commit for those (which is the default behavior). In this way, the command works very similarly to the above commands. Unlike with the merge and rebase commands, with this command the counsel merging the changes from the internal branch would have to explicitly commit on the master branch once the changes have been applied.&lt;/p>
&lt;p>So, to summarize, here are the steps that Party A's lawyers took:&lt;/p>
&lt;ol>
&lt;li>Initialize a blank repository for this matter (&lt;code>git init MATTER&lt;/code>).&lt;/li>
&lt;li>Create branch &amp;ldquo;internal&amp;rdquo; and switch to using that branch (&lt;code>git checkout -b internal&lt;/code>).&lt;/li>
&lt;li>Drop template into internal branch.&lt;/li>
&lt;li>Work on internal branch until satisfied.&lt;/li>
&lt;li>Checkout master branch (&lt;code>git checkout master&lt;/code>).&lt;/li>
&lt;li>Combine the work into one final commit within the master branch via one of the three commands above.&lt;/li>
&lt;/ol>
&lt;p>Once the lawyers for Party A are satisfied that the Draft 0 is ready to share with the lawyers for the counter party, they simply open up the master branch of the repo to Party B's lawyers.&lt;/p>
&lt;h2 id="steps-prior-to-negotiation----party-b">Steps Prior to Negotiation &amp;ndash; Party B&lt;/h2>
&lt;p>In this scenario, Party B's lawyers are simply responding to the draft contract submitted by Party A's lawyers. This is, of course, a simplified scenario to illustrate the point. In actuality, Party B and Party A could both have a starting contract they are interested in having as the basis for the final contract, but for the purposes of this exercise that adds unnecessary complexity. So let us stay with Party B simply responding to the initial draft produced by Party A.&lt;/p>
&lt;p>When Party A's lawyers open the repo to Party B, then Party B's lawyers will clone Party A's master branch (which is all they can see). After cloning the master branch, Party B's lawyers will immediately create their own &amp;ldquo;internal&amp;rdquo; branch. They would then conduct their review of the contract based on that &amp;ldquo;internal&amp;rdquo; branch. The commands used by Party B here follow the sequence above:&lt;/p>
&lt;ol>
&lt;li>Clone Party A's repo (&lt;code>git clone SERVER:REPO&lt;/code>).&lt;/li>
&lt;li>Create an internal branch (&lt;code>git checkout -b internal&lt;/code>).&lt;/li>
&lt;li>Do work.&lt;/li>
&lt;/ol>
&lt;p>Once the parties are ready then the negotiation would begin. I can think, conceptually at least, of a couple of ways in which the negotiation could be conducted. The first way would be to conduct a negotiation by breaking the negotiation into pieces and negotiating each piece. The second way would be to conduct the negotiation as a whole. The former is probably better for complex transactions, especially when there are teams of lawyers working on different pieces of the transactions. The latter is probably better for simple negotiations where the pieces negotiation is overly complex. Let's think through these in order.&lt;/p>
&lt;h2 id="negotiation-by-pieces">Negotiation by Pieces&lt;/h2>
&lt;p>Once Party B has noted (via its internal branch) the areas of the Draft 0 of the contract it has objections to, it would then classify these into issues. For each of the issues Party B wishes to address within the negotiation process, it would create a new branch off of Party B master branch. This is somewhat analogous to forming a topic branch in normal git flow.&lt;/p>
&lt;p>From each of the issue branches, Party B's lawyers could make the modifications to the contract they are interested in and send a pull request to Party A's lawyers. If the changes are agreeable to Party A, then those can be immediately merged into the master branch of both parties. Where changes require dialogue between the parties, that dialogue could happen within the comments on the web hosted repo, on email, over the phone, in person, however. In this instance, since the changes have been discreetly identified they can easily be merged into the master branch of both parties, changed by either party, or rejected as needed.&lt;/p>
&lt;p>This cycle could then be repeated as many times as necessary until both parties agree. So to summarize these steps:&lt;/p>
&lt;ol>
&lt;li>Party B: creates issue branches for each of the issues it has with the contract (&lt;code>git checkout master &amp;amp;&amp;amp; git checkout -b ISSUE_A&lt;/code>).&lt;/li>
&lt;li>Party B: counter proposes language for each of the issues within the issue branch in question.&lt;/li>
&lt;li>Party B: sends pull requests to Party A for each of the issues.&lt;/li>
&lt;li>Both parties: merge the issue branch into their master branches as issues are agreed in the direction of Party B's counter proposed language (&lt;code>git checkout master &amp;amp;&amp;amp; git merge ISSUE_A &amp;amp;&amp;amp; git branch --delete ISSUE_A&lt;/code>).&lt;/li>
&lt;li>Both parties: delete the issue branch from both repos as issues are agreed in the direction of Party A's originally proposed language (&lt;code>git checkout master &amp;amp;&amp;amp; git branch --delete ISSUE_A&lt;/code>).&lt;/li>
&lt;li>Both parties: work from the issue branch as the language goes back and forth (&lt;code>git checkout ISSUE_A&lt;/code>).&lt;/li>
&lt;li>Rinse and repeat as necessary.&lt;/li>
&lt;/ol>
&lt;p>When all of the topic branches have been merged into both masters or deleted without merging, then the negotiation is complete. Both parties should do a quick diff of the masters to ensure that there are no discrepancies. Thereafter the contract is ready for signature and execution.&lt;/p>
&lt;h2 id="negotiation-by-cycles">Negotiation by Cycles&lt;/h2>
&lt;p>Once Party B has noted (via its internal branch) the areas of the Draft 0 of the contract it has objects to, and it has refactored those provisions into its counter-proposed language, it would then &lt;code>git merge --squash&lt;/code>, &lt;code>git rebase --interactive&lt;/code>, or &lt;code>git cherry-pick --no-commit&lt;/code> those changes into its master branch. Once it has brought in its changes wholesale, it would send a pull request for the entire master branch to Party A.&lt;/p>
&lt;p>Thereafter Party A would work up its counterproposal via its internal branch after merging in the changes from Party B's master to Party A's internal. When it was ready with a counterproposal it would &lt;code>git merge --squash&lt;/code>, &lt;code>git rebase --interactive&lt;/code>, or &lt;code>git cherry-pick --no-commit&lt;/code> those changes into its master branch and send a pull request to Party B.&lt;/p>
&lt;p>This cycle would then continue until both parties were satisfied. So to summarize these steps:&lt;/p>
&lt;ol>
&lt;li>Party B: works on its counter proposal via its internal branch.&lt;/li>
&lt;li>Party B: brings in the changes to its master branch and sends pull request.&lt;/li>
&lt;li>Party A: merges Party B's master into its internal branch (&lt;code>git checkout internal &amp;amp;&amp;amp; git merge SERVER:REPO master&lt;/code>).&lt;/li>
&lt;li>Party A: works on its changes and brings those into its master via one of the three reductive commands above.&lt;/li>
&lt;li>Rinse and repeat as necessary.&lt;/li>
&lt;/ol>
&lt;p>When both of the parties have no further changes to the text, then the negotiation is complete. As with the prior methodology, both parties should perform a diff of the two masters to ensure that there are no discrepancies before the contract is fully ready for signature and execution.&lt;/p>
&lt;h2 id="conclusions">Conclusions&lt;/h2>
&lt;p>The advantage of the negotiation by cycles workflow is that there is less branching and moving pieces to worry about. Indeed it is rather similar to how negotiations are conducted at present but with an overlay of git which will retain all of the internal work as well as the communication between the clients (which to be fair both methodologies will do). The advantage of the negotiation by pieces workflow, though is that proposals and counterproposals which may contain numerous discrete issues to be addressed within a complex negotiation, are not separated out into pieces as they are in the previous negotiation workflow.&lt;/p>
&lt;p>Finally, when the parties have agreed to the substance of the contract, the lawyers for both parties can produce two distinct pieces of work. The first is the final contract which will be signed and executed as required for the jurisdiction in which it is being performed. The second would be an internal archive of the entire repo. This archive provides the &amp;ldquo;legislative history&amp;rdquo; of the contract and could illuminate some of the parties&amp;rsquo; intent if the contract were ever to be litigated. Of course, the admission of the repo archive would be subject to the rules of evidence at the time one of the parties sought to have it admitted, but that would be a discussion for another time.&lt;/p>
&lt;p>Happy Hacking!&lt;/p>
&lt;p>~ # ~&lt;/p></description></item><item><title>Recent Updates to Legal Markdown Gem</title><link>https://caseykuhlman.com/muniments/2013/2013-07-14-updates-to-legal-markdown/</link><pubDate>Sun, 14 Jul 2013 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2013/2013-07-14-updates-to-legal-markdown/</guid><description>&lt;p>Had some time this weekend and have dug pretty deep into my &lt;a href="https://github.com/compleatang/legal-markdown">legal_markdown&lt;/a> gem. Mostly the changes should be transparent to users. Now that I feel that am getting a better handle on Ruby, I wanted to refactor the code quite a bit. There were a couple of motivations for this. First, I wanted to put the code more inline with common rubyisms and software construction methods. Second, I wanted to make the gem more flexible. It was fairly straightforward as previously conceived. There was only one class, no modules, and all the functionality resided in one huge file. Third, speed. Although most lmd files will be quite tiny and any modern computer can parse them and refactor them into md files within milliseconds, faster is always &amp;gt; slower.&lt;/p>
&lt;h3 id="refactor-into-multiple-modules-and-classes">Refactor into Multiple Modules and Classes&lt;/h3>
&lt;p>I started the refactor by building two modules. First there is the main LegalMarkdown module which operates as the overall wrapper for the system. I wanted it to be a module so that other code (predominantly &lt;a href="https://github.com/compleatang/rmoc">RMOC&lt;/a>, which is upcoming once I release legal_markdown 1.0) can pull in the gem functionality in a more efficient and modular way. The LegalMarkdown module has a simple controller to direct the actions of the gem. For now it is fairly rudimentary, one of my next steps will be to utilize Ruby's OptionsParser now that the functionality of the gem is becoming more complicated. So the module operates as the parent of the gem, and has one method which controls what the gem does when the module is called. For now there are two modules which live directly &amp;ldquo;under&amp;rdquo; LegalMarkdown. The first module automatically builds the YAML front matter for users. This functionality has existed since v0.1.4 and I have to refactor that code in the coming times. The second module abstracted the LegalToMarkdown functionality into its own module.&lt;/p>
&lt;p>Similarly with the top level module, I abstracted LegalToMarkdown a bit. The entry point to the module is a controller file which determines how the module will perform. The file contains two methods. One of which controls the lmd -&amp;gt; md functionality and another which controls the lmd -&amp;gt; json functionality. There is probably too much logic in this file right now and I likely should abstract some of it to the LegalMarkdown controller which sets everything up to run a parsing incident more efficiently, but it is still a work in progress. To run the parsing incident I abstracted out the previous gem functionality into a couple of other files based on the steps required to parse a file. This is, perhaps, not optimal, but it is what makes sense to me.&lt;/p>
&lt;p>The first step to any parsing incident is to load and parse the input file. This content is an &amp;ldquo;thing&amp;rdquo; in ruby so it made sense that the content to be parse would be put in a class. When I call Class.new, Ruby will load the file, parse it, integrate the proper submodules of LegalToMarkdown module and get everything &amp;ldquo;ready&amp;rdquo; for the LegalToMarkdown controller to run the remainder of the parsing incident. Again, I'm not sure if this optimal software design as I'm still learning, but it seems to make sense to my and I can &amp;ldquo;visualize&amp;rdquo; where everything is at any point in the process.&lt;/p>
&lt;p>The rest of the process I abstracted into modules under LegalToMarkdown so that they can be integrated on a case by case basis depending on what the file needs to actually do. For instance if the file does not have a leaders block then there is no need to run that code. Similarly if the file does not have any mixins or optional clauses there is no need to run that code. It took me a while to figure out how to properly pull in the modules based on the conditions of the content. I still don't feel that I fully understand &lt;code>extend self&lt;/code> and &lt;code>self.extend&lt;/code> and &lt;code>include Module&lt;/code> but in any event, when extending a class with a module what ended up working based on the new design was to call &lt;code>self.extend LegalToMarkdown::Module&lt;/code> from a method in the class which parses the conditions to determine the correct modules to integrate.&lt;/p>
&lt;p>The portion of the code dealing with mixins was integrated into its own Module under the LegalToMarkdown module. Similarly the methods which parse leaders (structured headers) has been put into a different module under the LegalToMarkdown module. The last module I built deals with some particularities required for the &lt;code>--to-json&lt;/code> feature. So at the end of the day, the structure of the gem currently looks like this.&lt;/p>
&lt;blockquote>
&lt;p>module LegalMarkdown&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>-&amp;gt; module LegalToMarkdown&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>-&amp;gt; -&amp;gt; class FileToParse&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>-&amp;gt;-&amp;gt; module Mixin&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>-&amp;gt;-&amp;gt; module Leaders&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>-&amp;gt;-&amp;gt; module BuildJason&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>-&amp;gt; module MakeYAMLFrontmatter&lt;/p>
&lt;/blockquote>
&lt;p>Again, feedback on the structure is very much welcome as I'm still learning how to think about software design.&lt;/p>
&lt;h3 id="testing-suite">Testing Suite&lt;/h3>
&lt;p>I know, I know. You are supposed to have tests for what you do. How else will you know if it is working or not? I'm still learning! In any event, I took some time to build a testing suite. It was actually quite easy. And it greatly simplifies the development process. Thankfully, &lt;a href="https://github.com/twolfson">@twolfson&lt;/a> posted an issue on the github repo which sent me in the correct direction. He said I should build a bunch of simple flat files that represent the input and expected output. This is more or less what I had been doing, although I was not doing it systematically and was just doing it chaotically. Everything I read said that I should start out with testing using Ruby's included test suite rather than RSpec or other more intricate, and capable, test possibilities. So that is currently the basis for the suite. Later, when I'm more comfortable with the process I may switch to RSpec but for now Test::Unit is working just fine.&lt;/p>
&lt;p>One of the things that was important with a process oriented gem like legal_markdown is that when I test things there is a certain sequence in which I want the tests to run. So when I built the lmd files I simply numbered them. Then in the test controller I can simply glob the files, sort the resulting array and then it will always run the tests in a particular order that I want the files to be parsed. This allows me to check the operation of the gem in a particular sequence. That assists in understanding exactly where the problems. After building the lmd files then I ran those through the gem and tweaked a few things in the output markdown files (mostly which were bugs that I needed to work on). Boom, I had a working test suite.&lt;/p>
&lt;p>The basic philosophy for testing is to build these benchmark files. Then the test suite pulls the lmd files, puts them in order, then runs them one by one through the gem and outputs a temp file. Lastly, the test suite compares the temp file output to the benchmark file to ensure they are the same. Later when I add additional functionality or need to test different things, I can simply build a single lmd file that tests for what I need, output that to a md file as a benchmark, number it in the correct order in which I want the test to run and everything else will be taken care of.&lt;/p>
&lt;p>Once I had the test suite built. Then I had to work on the Rakefile to build the testing task. I integrated the github repo with &lt;a href="https://travis-ci.org">Travis&lt;/a> so that it will perform the tests for me on different versions of ruby. Generally I can test the gem quite quickly in 1.9.3 which is primarily what I use for development on my laptop. I run these tests after each piece of code after each piece of code that I've changed during the deeper refactor (below). The advantage of Travis is that it will run the tests on other versions of Ruby very quickly. But to use Travis, and to make running the tests more simple on my machine, I needed to build a rake task that would control the tests. It was very easy after a bit of googling and stack overflowing I had the answer within five minutes. I need to understand how to use rake better, but one thing at a time. For now, here's what the Rakefile looks like:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">require &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">bundler/gem_tasks&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
require &lt;span style="color:#e6db74">&amp;#39;rake/testtask&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">TestTask&lt;/span>&lt;span style="color:#f92672">.&lt;/span>new &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#f92672">|&lt;/span>t&lt;span style="color:#f92672">|&lt;/span>
t&lt;span style="color:#f92672">.&lt;/span>libs &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">test&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
t&lt;span style="color:#f92672">.&lt;/span>test_files &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">FileList&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;test/test*.rb&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
t&lt;span style="color:#f92672">.&lt;/span>verbose &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">:default&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">:test&lt;/span>&lt;span style="color:#f92672">]&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>It is very rudimentary for most, but it was cool for me to be able to type &lt;code>rake&lt;/code> into the command line (or if I was feeling verbose &lt;code>bundle exec rake&lt;/code>) and have it run the tests. Plus now Travis runs all the tests on the versions of Ruby which I specify in the .travis.yml file.&lt;/p>
&lt;h3 id="deeper-refactoring">Deeper Refactoring&lt;/h3>
&lt;p>Along with Travis, I also integrated the repo with &lt;a href="https://codeclimate.com">Code Climate&lt;/a>. Both of these tools are free for open source projects and make their money (as Github does) by providing the same, or similar, services for closed source project. I absolutely love this business model. Code Climate looks at your code and analyzes the complexity and redundancy of the code basis. Digging into its analysis of my code basis is teaching me a lot about coding and how to think about coding. For anyone that is reaching the advanced beginner stage of learning to code this is a fantastic tool.&lt;/p>
&lt;p>When I first integrated with Code Climate it gave me a rounding &amp;ldquo;F&amp;rdquo; and my GPA was 0.2. This was eye opening. It was one of the impetuses for my major refactor discussed above. After I parsed everything out into modules, etc. I also had to take a look at the methods and simplify those. Previously I had been thinking of methods as a way to control the flow of the code. So each of logical steps and substeps of the code were built as methods. It worked. But it is suboptimal for reasons I'm still learning. The basic jist is that I needed to greatly simplify what I was doing with my methods. So, mainly in the Leaders module I worked hard to refactor the code so that each method was more simple.&lt;/p>
&lt;p>Still, though, the code base is quite complex. I'm up to a GPA of 1.5 but I have a decent amount of work to do. Some of the complexity it appears to me is inevitable. There are a ton of complexities in what the gem is trying to do. There are ton of switches and branches depending on what the input is. In order to provide the functionality that I want, I'm still trying to figure out how to simplify the code base as much as possible. There appears a tension in what I'm trying to accomplish with the gem and the complexity of the codebase. However, this is hardly the most complex piece of code ever written. Much to learn; much to learn.&lt;/p>
&lt;h3 id="to-json-feature">To Json Feature&lt;/h3>
&lt;p>Some background. I started building legal_markdown because I wanted it to be a simple tool that could provide a basis for a new way of thinking about and creating legal documents. Yet, how to integrate with a ruby gem for non-technical, non-command line users, was a big concern. The average lawyer likely has never looked at the command line. Or at least, not since 1986. So it is fine that I have built in a command line option, but that is only the beginning. The next step was to integrate the gem into a sublime package. I use this package on a daily basis and it makes using the gem dead simple. Users can install sublime, install Package control, install the legal markdown package and go. Still there is the ruby requirement, but at least that is a surmountable obstacle.&lt;/p>
&lt;p>The problem with working with lmd files in sublime is primarily that it is not a very elegant solution for reading and annotating documents. Currently if I want to read a lmd file, it is damn easy. I simply run the Legal Markdown to Markdown command in sublime and then run the Preview Markdown command from the Markdown Preview package and it opens automatically in the browser. Two commands. It is not bad, but it could be better.&lt;/p>
&lt;p>These are some of the concerns behind &lt;a href="https://github.com/compleatang/rmoc">RMOC&lt;/a>. To read and annotate files will require a more complex structure than simple markdown is capable of providing. There are a couple of options for richer file formats than simple text based format such as markdown. For now, the primary &amp;ldquo;rich&amp;rdquo; format that legal_markdown will support is JSON. As I stated in this &lt;a href="https://github.com/compleatang/legal-markdown/issues/2">issue&lt;/a> , JSON is readily available for all major programming/scripting languages; generally parses faster and is easier to work with than xml (the other major option); and also integrates with databases very well.&lt;/p>
&lt;p>In addition, I've been a fan for a while of what the team building &lt;a href="http://substance.io">Substance&lt;/a> is doing. So, I've built the to-json feature of legal_markdown so that it outputs in a format which will fully integrate with Substance. Then when I build the Read component of RMOC I can simply use a lot of their code to build the reading and annotating portion of RMOC.&lt;/p>
&lt;p>Building the feature was not really troublesome. Once you have a good idea of how to work with hashes in ruby then it is really a simple matter to build JSON documents. You simply assemble the code into one large hash and then dump that hash into a JSON.&lt;/p>
&lt;h2 id="lessons-learned">Lessons Learned&lt;/h2>
&lt;ul>
&lt;li>Classes = things. Files are things. A file is a Class. Functionality goes in modules&lt;/li>
&lt;li>Modules are ways to keep blocks of code so that they can be integrated when necessary&lt;/li>
&lt;li>Methods should have a singular function&lt;/li>
&lt;li>Nested hashes area bit troublesome when the keys are id's and you only know the values rather than the keys. Have to loop through each_value and work the search that way. Also, Enumerable::detect is good for this.&lt;/li>
&lt;li>Don't be afraid of tests. They aren't that complex.&lt;/li>
&lt;/ul>
&lt;p>Happy Hacking!&lt;/p>
&lt;p>~ # ~&lt;/p></description></item><item><title>Sublime Legal Markdown Package Updated</title><link>https://caseykuhlman.com/muniments/2013/2013-04-19-sublime-legal-markdown-package-pandoc-update/</link><pubDate>Fri, 19 Apr 2013 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2013/2013-04-19-sublime-legal-markdown-package-pandoc-update/</guid><description>&lt;p>Finally had a chance to update my &lt;a href="https://github.com/compleatang/Legal-Markdown-Sublime">legal markdown package&lt;/a> for Sublime. The package is built to fill a couple of holes in the system that I use.&lt;/p>
&lt;p>As background, I use Sublime as my main IDE both for coding and for my legal work. I use a word processor, but only to review client documents and to do a final review on documents that I build. All the documents that build, I do so in Sublime. I write regular memos in regular markdown and pandoc them to ODT, double check the formating and output to PDF (and docx if the client needs it) using Libre's &lt;a href="http://extensions.libreoffice.org/extension-center/multisave-1">multiformat save extension&lt;/a>. I draft laws, regulations, contracts, and corporate governance documents in &lt;code>lmd&lt;/code> format, use legal_markdown package to push them (interstitially to normal markdown and then via pandoc) to ODT.&lt;/p>
&lt;p>The system worked fine, but I did have to pull down my &lt;a href="http://www.webupd8.org/2013/03/terra-terminal-update-brings-improved.html">Terra terminal&lt;/a>, cd to the proper directory and run the pandoc command &amp;ndash; after converting the &lt;code>lmd&lt;/code> file in Sublime to normal markdown. So I knew I wanted to combine some of the better aspects of the various pandoc - sublime integrations (there are at least three that I know of) with the legal_markdown preprocessing.&lt;/p>
&lt;p>I've now pushed the result. One of the differences in my implementation of pandoc integration (beyond the preprocessing by the legal_markdown gem obviously) is to utilize a document type definitional system. Basically, I wanted to be able to define different output document types and to pre-establish all of the pandoc options for these in my user settings file for the package. Then, when I wanted to export the &lt;code>lmd&lt;/code> file I just wanted a quick panel to show up where I could choose the export document type and let the package and pandoc take care of adding the correct mix of settings.&lt;/p>
&lt;p>I think it works fine. Basically in the user settings, you add &amp;ldquo;build-format&amp;rdquo; keys and for each key you add a document type name (what will show up in the quick panel) key. Then inside this key you add whatever pandoc options you want. There are four main options that the package will use: &amp;ldquo;from&amp;rdquo; (pandoc's reader options), &amp;ldquo;to&amp;rdquo; (pandoc's writer options), &amp;ldquo;file-output&amp;rdquo; (triggers pandoc's -o flag), and &amp;ldquo;options&amp;rdquo; (which you can use for general options such as &amp;ndash;normalize -S flags which are technically writer options but I think of them as general options). Each of the fields (except for the &amp;ldquo;file-output&amp;rdquo; field) should be an array. The &amp;ldquo;file-output&amp;rdquo; field should be either &amp;ldquo;true&amp;rdquo; or deleted. If it is deleted then the package will replace the currently active buffer with pandoc's output. Usually, for this package's purpose you will almost always want to have it asa true.&lt;/p>
&lt;p>Lastly, I wanted the package to automatically open a file for me. In other words when I'm converting a &lt;code>lmd&lt;/code> file to &lt;code>odt&lt;/code> I want to switch over to libreoffice to review the file. So the package also adds an optional field to each document type called &amp;ldquo;open-file-after-build&amp;rdquo;. This field is a simple command that you will call to open the file. The package will fill in the file that is outputted by pandoc after the command. So you &lt;strong>do not&lt;/strong> need to type &amp;ldquo;libreoffice $FILE&amp;rdquo; into the settings file, you simply need to type &amp;ldquo;libreoffice&amp;rdquo; into the settings file and the package will take care of the rest.&lt;/p>
&lt;p>I have not tested the auto open in OSX or Windows so if anyone else has those boxes and can test it, that would be fantastic. I'm happy to work to make it cross platform compatible as much as I can.&lt;/p>
&lt;p>Still have a bit more work to go on the package as you can see from the roadmap but it is now one step closer to where I'd like it to be.&lt;/p>
&lt;p>Happy Hacking!&lt;/p>
&lt;p>~ # ~&lt;/p></description></item><item><title>My (Current) Transactional Documents Work Flow</title><link>https://caseykuhlman.com/muniments/2013/2013-03-09-transactional-documents-workflow/</link><pubDate>Sat, 09 Mar 2013 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2013/2013-03-09-transactional-documents-workflow/</guid><description>&lt;p>While it varies, I generally will have two meetings with a client before I will build the initial draft of the contract.&lt;/p>
&lt;p>In the first meeting, I will try to ferret out what the client is trying to achieve. This is generally an overview meeting. Mostly, Somalis do not like doing too much in any one meeting &amp;ndash; especially if they do not know you well. So I try to keep the goals of what I need to achieve in these meetings realistic and limited. During this meeting, I try to give them an idea of in which direction we are likely to take the transaction in terms of what types of contract(s) are going to be involved to facilitate and integrate the transaction. I also usually try to give the client a few of the key, and usually poignant, decisions that they will have to make so that they can mull it over between the first and second meetings.&lt;/p>
&lt;p>In the second meeting, I will ask a lot more specific questions. This meeting is all about the details. Prior to the meeting I will have planned out the transaction documents and forked the appropriate templates of whatever documents will be required for the transaction. I use the specific forks of the primary templates as the basis of my checklist for the transaction. This is easy when building templates in legal_markdown form and sublime. I have been building (but haven't open sourced it yet) a small script that automates this process for me. In my contract templates I just type &lt;code>...?ASK?...&lt;/code> or &lt;code>...?CONFIRM?...&lt;/code> and then the script finds these and builds them into a checklist specific to the transaction.&lt;/p>
&lt;p>I know a lot of transactional attorneys like to build checklists based on the type of transaction. I have a few of those, but I find that usually I spend more time deleting irrelevant items and overall they are inefficient for me. I prefer to build questions into my document templates and then to build my checklist for the transaction based on the document templates that I'm going to use.&lt;/p>
&lt;p>For example, this week I've been working on two different joint venture agreements. They are very different from one another and are based on two different templates (one of which is a fork of the main JV template that I have built). For me, it is more efficient to pull my checklists from each of the templates than it would be to fork a main joint venture checklist and then adapt that for each type of transaction.&lt;/p>
&lt;blockquote>
&lt;p>In other words, the key is to integrate your checklist building with your template building. This has many distinct advantages, not the least of which are precision and efficiency.&lt;/p>
&lt;/blockquote>
&lt;p>The script that builds the checklists for me in sublime produces a list of questions. These provide me with the base the agenda of the second, more detail oriented, meeting with the client. Usually I print the checklist as I find that Somalis usually find a screen in the room either disrespectful or disorienting. So I usually just write my answers on the printed checklist.&lt;/p>
&lt;p>After that second meeting, I build the first drafts of the documents necessary for the transaction. As I said earlier, I build my templates into a main repo and then fork the necessary templates from the main repo into the repo for the client. When I build templates I fill them with mixins, optional clauses, and questions. All I have to do after the second meeting is to fill in the answers to the questions that I have by replacing all the &lt;code>...?QUESTIONS?...&lt;/code> with the answers. Usually this just means filling in the YAML front matter of the template.&lt;/p>
&lt;p>Once I have finished answering the questions, entering the mixins and selecting or deselecting the optional clauses (all of which I do in the YAML front matter), I simply save the legal_markdown file &amp;amp;&amp;amp; pandoc it based on my contract template .odt. Then I open the .odt in libreoffice where I do a final read through of the contract, tweak the styles if necessary, and save as .pdf / .doc / .odt or whatever the client needs to review the document. All of these steps (minus the final review in libreoffice) I perform from sublime. I build the templates there, I massage the YAML front matter there, I pandoc from there, and I open the .odt file from there. It is basically a full scale contracts IDE for me.&lt;/p>
&lt;p>After the client has reviewed the documents I will sometimes edit in Sublime, but if the changes are marginal then I find it more efficient to make the changes in Libreoffice and voila. Done.&lt;/p></description></item><item><title>Pandoc for Legal Documents</title><link>https://caseykuhlman.com/muniments/2013/2013-01-24-pandoc-legal-documents/</link><pubDate>Thu, 24 Jan 2013 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2013/2013-01-24-pandoc-legal-documents/</guid><description>&lt;p>Lately, I have been writing a lot in markdown. It is a freeing way to write documents because you focus more on the words than the tools around you in the wordprocessing interface. You pick your favorite environment to write &amp;ndash; for me it is Sublime Text &amp;ndash; and then you write. But, clients and courts do not read Github Flavored Markdown.&lt;/p>
&lt;p>This is where &lt;a href="http://johnmacfarlane.net/pandoc/index.html">Pandoc&lt;/a> comes into play. Pandoc is one of the many markdown renderers / translators available. You can think of it like a swiss army knife for changing document types. The thing that makes Pandoc quite interesting, for my purposes as a lawyer, is that it when you translate your markdown into an .odt file (or .docx for those who like completely bloated, prorietary things) you can establish exactly how the end document will look.&lt;/p>
&lt;p>What you do is first output some markdown text into an .odt file. Then you go into LibreOffice and modify the styles so that they are appropriate. I have templates setup for most of the documents I create and I simply linked the main styles that I use in my markdown to the ones in the template .ott files. I created multiple Pandoc .odt templates (which Pandoc calls reference files) to more or less mirror my .ott files.&lt;/p>
&lt;p>In Sublime, I &lt;a href="https://github.com/compleatang/sublimetext-Pandoc">forked&lt;/a> the excellent Pandoc plugin to modify it so that I could build custom templates and added a few other goodies so that Pandoc would play nicer with .odt files (which were not included in the original version). Using the forked Pandoc plugin I can simply output my markdown files to the appropriate reference file. I use the SideBarEnhancements plugin to right click on the newly created .odt and open in Libre to finalize everything. Mainly this entails dropping in my citations from Zotero and making sure that the styling is fine and everything is looking as it should. Save the new .odt file in GDrive. Output the .pdf to GDrive. Close the task on Teambox. Email the client. Done.&lt;/p>
&lt;p>One of the most annoying things about using a wordprocesser and doing research is the new lines that pdf copy places on your clipboard. Since Python is a relatively straightforward language and not &lt;em>that&lt;/em> different from Ruby for simple text manipulation, and since Sublime offers a very easy to understand API, it was quite easy &amp;ndash; even for a beginner such as I &amp;ndash; to &lt;a href="https://github.com/compleatang/sublimetext-pastepdf">build a plugin&lt;/a> that will allow me to ctrl+alt+v and thus strip the newlines so that the text block pastes as a single text block.&lt;/p>
&lt;p>Because Pandoc has inline footnoting, when I'm writing I simply drop in a marker quickly where I need to reference things. When Pandoc translates the markdown into an .odt file it builds the footnotes with the markers I need (usually pinpoints). Then I can simply inserting the citations from Zotero. When I was doing some research the other day I realized that FastCase does not have a translator for Zotero so I started working on one. It will be coming soon. And more about integrating Zotero and LibreOffice for legal research will accompany that.&lt;/p>
&lt;p>For legal documents, particularly client focused documents, you don't really need that much formatting. Indeed the less the better. Really you need only a handfull of styles within the document. Using a system such as this to force the proper styling techniques you can easily roll branding rules for your small firm and also let lawyers focus on the text rather than another Format Paste.&lt;/p>
&lt;p>Admitedly, collaboration is still imperfect. A huge percentage of lawyers still are on Word and so the .doc and .docx formats and awful Calibri are not going away anytime soon. There is no simple way, when you need to track changes and integrate comments into a document, to utilize some of the tools that make writing so much more enjoyable on a text processor. Luckily, however, using these techniques allows me to limit my time in a word processor &amp;ndash; even a quite nice one like LibreOffice.&lt;/p>
&lt;p>~ # ~&lt;/p></description></item></channel></rss>