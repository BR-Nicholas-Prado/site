<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>underWater desert Blogging</title><link>https://caseykuhlman.com/</link><description>A Site About Resilience and Authoritarianism</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>casey@caseykuhlman.com (Casey Kuhlman)</managingEditor><webMaster>casey@caseykuhlman.com (Casey Kuhlman)</webMaster><copyright>All Content Licensed CC BY-NC-SA 4.0</copyright><lastBuildDate>Wed, 29 Jan 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://caseykuhlman.com/categories/linux-for-lawyers/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Dropbox as a Settings Repository</title><link>https://caseykuhlman.com/muniments/2014/2014-01-29-dropbox-as-a-settings-repository/</link><pubDate>Wed, 29 Jan 2014 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2014/2014-01-29-dropbox-as-a-settings-repository/</guid><description>&lt;p>As I said in my previous post, the main way in which I used Dropbox is as a repository for all my settings. Almost the entirety of this will also work with OSX for the record, save for program settings locations in OSX are different than in Linux &amp;ndash; they are usually in ~/Library/Application\ Settings.&lt;/p>
&lt;h2 id="how-linux-usually-stores-settings">How Linux (Usually) Stores Settings&lt;/h2>
&lt;p>One of the most brilliant things about Linux systems is how Linux desktops (for the most part) store your application settings. On Windows, these are usually stored in databases which makes them difficult to sync and store. But on POSIX systems generally, and Linux in particular, settings for applications are largely stored in files. Indeed, usually files are simple text files rather than anything which is truly difficult to handle.&lt;/p>
&lt;p>There are two main implications for the operating system utilizing files rather than databases for application settings. The first is that you can move the files around to where &lt;strong>you&lt;/strong> want them to be rather than where the &lt;em>developers&lt;/em> think they should be and then you can fake the computer into thinking the files are really where the program is looking for them at. The second implication is that it is terribly easy to set your settings up to be cloud synced which means that you can always pull them in when you have a new machine or setup.&lt;/p>
&lt;h2 id="the-importance-of-installation-scripts">The Importance of Installation Scripts&lt;/h2>
&lt;p>One of the major things which Linux has showed me is how to create a fungible system. I use Ubuntu which is on a six month release cycle. This means that every six months or so I will completely format my hard drive and start from scratch.&lt;/p>
&lt;p>In the 90's I had a friend in college who used to format his hard drive all the time. He would take like one weekend every quarter and do this. It was ridiculous. At that time he was running Windows I'm pretty sure so I had no idea why he would do it so often. Perhaps he was not on Windows and had figured out back then what I know now which is that if you set things up correctly, formatting your hard drive and reinstalling everything can happen smoothly, resiliently and easily.&lt;/p>
&lt;p>At this point when I update my Ubuntu release and format my hard drive the first thing I do after logging in is download and run one script. That script is a master script which runs all sorts of smaller scripts. It takes about an hour or maybe three to download and install everything depending on the bandwidth of my connection &amp;ndash; but even in Hargeisa where the bandwidth is awful it runs in about three hours. When it is finished, I have only a few things to do (like turn on a few extensions for Ubuntu-GNOME and maybe change my wallpaper) and my system will look and act &lt;strong>exactly&lt;/strong> as it did before the new installation. I will write more about this process later. Suffice it to say for this post that my Dropbox bootstrap script is a huge part of that.&lt;/p>
&lt;h2 id="setting-up-a-dropbox-bootstrap-script">Setting up a Dropbox Bootstrap Script&lt;/h2>
&lt;p>Given all the above, about two years ago I realized that what I needed to do was to put all of my non-data non-music non-document non-video files that I would need to make my system look and feel the same across installations in my Dropbox. Dropbox works exceedingly well for this. In Linux most programs look for their configuration file in one of a few places.&lt;/p>
&lt;ul>
&lt;li>Some programs look for a file in the home folder which is usually the name of the program + rc. So for example, the program htop which is a great program for seeing the processes that are currently running and a whole lot more stores its settings in ~/.htoprc.&lt;/li>
&lt;li>Some programs look for a set of files within ~/.config/PROGRAM_NAME/FILES.&lt;/li>
&lt;li>Some programs, particularly desktop (as in GNOME, Unity, Elementary, etc.) files and menus, in a various directories under ~/.local/share/STUFF.&lt;/li>
&lt;li>Some programs make a folder in your home directory and put files under there. Usually these are in a folder called something like ~/.PROGRAM_NAME. For example, filezilla a popular FTP program puts its configuration files under ~/.filezilla&lt;/li>
&lt;/ul>
&lt;p>If you do not know in Linux terms, the &lt;code>~&lt;/code> in the above is a &amp;lsquo;contraction&amp;rsquo; for &lt;code>/home/USER&lt;/code>. This is standard across POSIX systems and is a highly utilized shorthand.&lt;/p>
&lt;p>Since programs have different methods of placing their configuration files, setting up your own cloud sync for program settings will require that you look around in your home folder. If you are doing this, it is important to understand that when a file has a &lt;code>.&lt;/code> in the beginning of it on Linux that is a hidden file and it will not show up in Nautilus unless you press &lt;code>ctrl+h&lt;/code> (for Hidden). If you are in terminal &amp;ndash; which I highly recommend everyone to learn at least the basics of &amp;ndash; then you will not see hidden files when you type &lt;code>ls&lt;/code> (LiSt files) unless you add the &lt;code>-a&lt;/code> (for All) switch to make the command &lt;code>ls -a&lt;/code>.&lt;/p>
&lt;p>The key to the whole system is creating &lt;code>symlinks&lt;/code> (symbolic link) within your user folder. Symbolic links are what makes the programs &lt;em>think&lt;/em> they are looking at a file in one place when they are &lt;em>really&lt;/em> looking at a file in another location. Files which are really symlinks look, act, and feel almost exactly as if they were actually in the place where the symlink resides rather than in the place where they actually are.&lt;/p>
&lt;p>Once you have found the files that you want to have synced to the cloud it is a rudimentary process to set them up. The basic flow is as follows:&lt;/p>
&lt;ol>
&lt;li>Copy the files into your cloud sync folder.&lt;/li>
&lt;li>Create a &lt;em>from&lt;/em> the new location in the cloud sync folder &lt;em>to&lt;/em> the previous location where the program will really look for it.&lt;/li>
&lt;/ol>
&lt;p>It is truly just that simple. If you want to symlink directories there is the added step of checking to see if a directory is made within the cloud sync folder and making the directory within the cloud sync folder if it is not. But that is the only added step. If you create a symlink directory, it operates &amp;ndash; for all intents and purposes &amp;ndash; just as a normal directory does. It has files inside of it and programs can look inside of the directory at the files just as they normally would.&lt;/p>
&lt;h2 id="wrapping-it-all-up-in-an-executable-script">Wrapping it All up in an Executable Script&lt;/h2>
&lt;p>To automate this process is very straight forward. You simply want to create an executable script and put it in your cloud sync folder. Then you simply call that script whenever you like. Here is what I did.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ touch ~/Dropbox/bootstrap
$ chmod +x ~/Dropbox/bootstrap
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first line creates a bootstrap file within my Dropbox folder; the second line makes it executable. At this point the file is simply blank. So then one needs to put something into the script to make it work. Here's excerpts from my bootstrap file.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e">#!/usr/bin/env zsh
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#^jist /home/coda/Dropbox/bootstrap -u 4950102&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> ! -d ~/Dropbox/Dot-Files &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
mkdir Dropbox/Dot-Files/
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> file_boot &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -f $1 &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#f92672">[&lt;/span> ! -L $1 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ! -e $2 &lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
cp $1 $2
&lt;span style="color:#66d9ef">fi&lt;/span>
rm $1
ln -s $2 $1
&lt;span style="color:#66d9ef">elif&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -e $2 &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
ln -s $2 $1
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> dir_boot &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -d $1 &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#f92672">[&lt;/span> ! -L $1 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ! -e $2 &lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
cp $1 $2 -R
&lt;span style="color:#66d9ef">fi&lt;/span>
rm -rf $1
ln -s $2 $1
&lt;span style="color:#66d9ef">elif&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -e $2 &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
ln -s $2 $1
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;First the dot files.&amp;#34;&lt;/span>
file_boot ~/.face ~/Dropbox/Camera&lt;span style="color:#ae81ff">\ &lt;/span>Uploads/0000.gravatar.jpeg
file_boot ~/.gitconfig ~/Dropbox/Dot-Files/gitconfig
file_boot ~/.gitattributes ~/Dropbox/Dot-Files/gitattributes
file_boot ~/.config/gtk-3.0/bookmarks ~/Dropbox/Dot-Files/gtk-bookmarks
file_boot ~/.installd ~/Dropbox/Dot-Files/installd-workers
file_boot ~/.rvmrc ~/Dropbox/Dot-Files/rvmrc-workers
file_boot ~/.vimrc ~/Dropbox/Dot-Files/vimrc-workers
file_boot ~/.npmrc ~/Dropbox/Dot-Files/npmrc-workers
file_boot ~/.zshrc ~/Dropbox/Dot-Files/zshrc-workers
echo &lt;span style="color:#e6db74">&amp;#34;Then come the config directories.&amp;#34;&lt;/span>
dir_boot ~/.ssh ~/Dropbox/Ssh
dir_boot ~/.bin ~/Dropbox/Binary&lt;span style="color:#ae81ff">\ &lt;/span>Files
echo &lt;span style="color:#e6db74">&amp;#34;Thereafter we take care of the menus and desktop.&amp;#34;&lt;/span>
dir_boot ~/.config/autostart ~/Dropbox/Autostart&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.config/
dir_boot ~/.config/menus ~/Dropbox/Menus&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.config
dir_boot ~/.local/share/gnome-shell/extensions ~/Dropbox/Gnome-shell&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.local-share/
dir_boot ~/.local/share/applications ~/Dropbox/Menus&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.local-share-applications
dir_boot ~/.local/share/desktop-directories ~/Dropbox/Menus&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.local-share-directories
dir_boot ~/.config/elegance-colors ~/Dropbox/Elegance&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.config
dir_boot ~/.icons ~/Dropbox/Icons
echo &lt;span style="color:#e6db74">&amp;#34;Finally come the \&amp;#34;other\&amp;#34; working directories.&amp;#34;&lt;/span>
dir_boot ~/.cheat ~/Dropbox/Cheat-Sheats
dir_boot ~/.config/libreoffice ~/Dropbox/Libreoffice&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.config
dir_boot ~/.conky ~/Dropbox/Conky
dir_boot ~/.filezilla ~/Dropbox/Filezilla
dir_boot ~/.fonts ~/Dropbox/Fonts
dir_boot ~/.gconf/apps/guake ~/Dropbox/Guake&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>.gconf&lt;span style="color:#ae81ff">\ &lt;/span>-&lt;span style="color:#ae81ff">\ &lt;/span>apps
echo &lt;span style="color:#e6db74">&amp;#34;All done! Dotfiles built!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let's walk through the script. The first line is called a shebang. It tells the computer in what scripting language the script should be run in. I chose to run this in zsh as that is my normal shell. The other major shell language, bash, could be used but there are some minor differences in the functions that would need to be worked out.&lt;/p>
&lt;p>For most of my executable scripts, I make sure they are on Github's Gist system so that I can easily remember and retrieve them. &lt;code>jist&lt;/code> is a command line gem written in ruby that makes it easy to post, retrieve and update your Gists. I usually make a caseybang(tm) reminding myself what the code for the gist is by putting the second line as a jist line. Then I simply can copy and execute this from the command line. Largely it can be ignored.&lt;/p>
&lt;p>The next section looks in the Dropbox folder to see if there is a Dot-Files directory. If it is not there then the script will make one. I have one there, but this is just for resiliency in the off chance that something weird happens during an upgrade. After that there are two functions which are built, file_boot and dir_boot. They do more or less what they sound like. One bootstraps individual files and one bootstraps directories.&lt;/p>
&lt;p>[Note, in the following paragraphs the &lt;strong>first&lt;/strong> ($1 in the script) means the local or normal place on the hard drive &amp;ndash; where the program will look for the file or directory; the &lt;strong>second&lt;/strong> ($2 in the script) means the cloud sync location.]&lt;/p>
&lt;p>What the function does is asks some questions. First it asks whether the first ($1) exists as a file (-f) or directory (-d) depending on whether the file_boot or dir_boot function is being called.&lt;/p>
&lt;p>If it exists then the function will then ask if the first ($1) is a symlink AND whether the second ($2) exists. This usually means that I have added a file or directory to the script and it needs to bring it into my Dropbox. If this test is satisfied then the function will copy the first to the second. But if the first exists and is not a link AND the second exists then we are in a different world. This usually means that I'm reinstalling a system so we do not want to copy in the file (or directory) to the cloud sync folder as it will then overwrite my existing settings with the default settings (which is usually when this test is satisfied). After either copying over or not, depending on the test, the function will then remove the first ($1) and create a symlink from the second to the first.&lt;/p>
&lt;p>If the first ($1) does not exist (in other words the initial test was not satisfied), but the second ($2) exists then the function will create a symlink from the second to the first.&lt;/p>
&lt;p>That is it. It is very straight-forward. It took some massaging to get the functions correct, but once I realized the flow then it was straight-forward to create the tests and actions.&lt;/p>
&lt;p>After the script establishes the function then it simply lists the files and directories to symlink. I've put a redacted version of my complete list above to show the different locations and how I organize it. Some highlights include, autostarting settings. I keep my autostart settings in Dropbox so when I install a new system the same programs autostart. Try that in windows. Also my menus are the same across systems &amp;ndash; even for programs which I have manually placed into the desktop. Try that in windows. My desktop themes, icons, and extensions are also there so that my desktop will look and feel almost the same even when Gnome-Shell upgrades. Try that in windows.&lt;/p>
&lt;p>As I go along and add or remove programs which I want to add their settings to the dropbox folder then I simply add a new line into the appropriate section of the script by adding &lt;code>file_boot LOCAL_LOCATION SYNC_LOCATION&lt;/code> or dir_boot depending on whether it is a file or directory I'm bootstrapping. After adding the line, I save the file and then execute the script. Voila, the file is copied into my Dropbox and symlinked to.&lt;/p>
&lt;p>When I'm installing my next update and format my harddrive, one of the first things I do in my install script is to begin downloading my dropbox. Then later in the script when it is all downloaded, I simply execute this script from the main install script which symlinks everything in and deletes the defaults which Ubuntu install wizard sets up. Voila, everything as it was before.&lt;/p>
&lt;h2 id="improvements">Improvements&lt;/h2>
&lt;p>This script could be improved by pulling out the ~/Dropbox portion into a variable and putting that variable at the top of the script for those who may use the script in a different system or have their dropbox folder in a different location. Other than that if you have improvements definitely let me know, but all in all it is quite straightforward.&lt;/p>
&lt;p>At any rate, hope this is somewhat useful.&lt;/p>
&lt;p>Happy Hacking&lt;/p>
&lt;p>~ # ~&lt;/p></description></item><item><title>Cloud Sync and Backup Options -- Overview</title><link>https://caseykuhlman.com/muniments/2014/2014-01-28-cloud-sync-and-backup/</link><pubDate>Tue, 28 Jan 2014 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2014/2014-01-28-cloud-sync-and-backup/</guid><description>&lt;p>Backup your files. Everyone knows it. Even those who know very, very little about computers understand that you should back things up. But no one does. Let's talk quickly about the options which Linux has for backing up your files.&lt;/p>
&lt;p>Cloud sync is not terribly new, but it has definitely been mainstreamed within the past year or two. Increasingly, bar associations have been distributing ethics opinions on how lawyers should keep their client's data safe. So far, no bar association that I know of has said outright that lawyers within their jurisdiction cannot keep their client files backed up to the cloud. I certainly know many lawyers who are skeptical about cloud backup and as a result do not do it.&lt;/p>
&lt;p>Yet not using the cloud comes with a limitation, because cloud syncing is damn powerful. You have the ability to access your files from anywhere. You have the ability to very simply and quickly reconstitute your data after getting a new computer, formating an existing system, or when you are on a system which is not your main system.&lt;/p>
&lt;p>I use three cloud syncing systems (two commercial providers and one that I have built for Watershed) and a physical external hard drive to back up my data. Everything that is important to me &amp;ndash; literally everything &amp;ndash; is put onto at least one of the proprietary cloud syncing services as well as my own, secure cloud server which I completely control, as well as my external hard drive. I have my data in different data centers, on different continents, and on different types of drives. It would take nuclear annihilation of the human species for me to lose anything more than a few file updates.&lt;/p>
&lt;p>Having your data in more than one place requires that you understand the security structure of that data. For this reason my external hard drive does not travel with me &amp;ndash; because despite my previous advice it is not encrypted. For this reason I have a highly secure server hosted within Watershed's cloud that serves to only accept our git repositories and our partner's backups. I'll get to how we structure that process in a later post.&lt;/p>
&lt;h2 id="how-i-structure-my-cloud-syncing-system">How I Structure My Cloud Syncing System&lt;/h2>
&lt;p>I use two commercial cloud sync providers, but I do not use them for the same thing. That would be a waste of the free space cloud providers offer. Personally, I use Dropbox and Google Drive. I use Dropbox as, well, a dropbox but the main way I use Dropbox is as a repository for all my configuration files. In an upcoming post, I'll walk through my Dropbox bootstrapping system, but it is very similar in nature to the system by &lt;a href="https://github.com/lra/mackup">Mackup&lt;/a>. The basic idea is that I copy folders and files into specific spots on my Dropbox and then symlink to those. I use Google Drive for all my client and internal Watershed documents. Both of my Dropbox and Google Drive are then backed up on a daily basis to Watershed's server and to my external hard drive in the office.&lt;/p>
&lt;p>There is no reason to backup one cloud provider into another either by putting one inside the other or by symlinking between them. Not only would it be a waste of valuable space, but also it &lt;em>could&lt;/em> create an infinite loop where one or both systems were constantly updating. Since both of these services at least count versions of files against your data caps, if you tried to back up one system to another you would likely have so many versions of some files that you could creep up on your data cap quickly.&lt;/p>
&lt;p>I find Dropbox to be faster for smaller files and Google Drive to be faster for larger files. I have no benchmarks for this, it is simply how it feels. Which makes this distribution of effort important.&lt;/p>
&lt;h2 id="rsync----still-crazy-after-all-these-years">Rsync &amp;ndash; Still Crazy After All These Years&lt;/h2>
&lt;p>Where cloud sync providers are amazing is in how fast they can update your cloud with your files. It is grand. But you don't actually always want things to be instant. Sometimes you want to go slow. When I'm in Somaliland for instance where bandwidth can be limited I do not want to necessarily take valuable bandwidth that I may need to do research or check facebook by allowing cloud sync services to update too frequently.&lt;/p>
&lt;p>This is why my backups to Watershed's servers and my on-site external drive are performed on a daily basis. I set my backups to run via rsync on a cron job so I never need to worry about them. What I love about posix systems is how simple they make it to build a small script and what I love about linux is how easy it is to set up a cron job to run the small scripts on whatever basis you want the script to run. These two concepts in combination with rsync makes for a completely hassle free system. If you do not have rysnc on your system then simply &lt;code>sudo apt-get install rysnc&lt;/code> or install it from your app store.&lt;/p>
&lt;p>First, I built a backupjobs script in my &lt;code>~/.bin&lt;/code> folder:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
USER&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>who am i | awk &lt;span style="color:#e6db74">&amp;#39;{print $1}&amp;#39;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
BASIS&lt;span style="color:#f92672">=&lt;/span>/home/$USER
EXTERNAL_HD&lt;span style="color:#f92672">=&lt;/span>/media/$USER/MediaHD
GANDI_DRIVE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#75715e">#REDACTED -- THIS IS THE CLOUD DRIVE&lt;/span>
IS_GANDI_THERE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>nmap $REDACTED -PN -p ssh | awk &lt;span style="color:#e6db74">&amp;#39;{print $2}&amp;#39;&lt;/span>|grep open&lt;span style="color:#e6db74">`&lt;/span>
IS_EXTERNAL_HD_MOUNTED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>mount 2&amp;gt; /dev/null | grep &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$EXTERNAL_HD&lt;span style="color:#e6db74">&amp;#34;&lt;/span> | cut -d&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> -f3&lt;span style="color:#e6db74">`&lt;/span>
&lt;span style="color:#75715e"># STEP 1 - BACKUP to GANDI IF GANDI&amp;#39;S THERE&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$IS_GANDI_THERE&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#f92672">]&lt;/span> ;&lt;span style="color:#66d9ef">then&lt;/span>
rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/Dropbox $GANDI_DRIVE
rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/Insync/caseykuhlman@gmail.com $GANDI_DRIVE/GDocs
rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/Insync/caseykuhlman@watershedlegal.com $GANDI_DRIVE/GDocs
rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/sites/ $GANDI_DRIVE/Coding
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#75715e"># STEP 2 - BACKUP to EXTERNAL HD IF IT&amp;#39;S THERE&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$IS_EXTERNAL_HD_MOUNTED&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#f92672">]&lt;/span> ;&lt;span style="color:#66d9ef">then&lt;/span>
&lt;span style="color:#75715e">#rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/Dropbox $EXTERNAL_HD&lt;/span>
rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/Insync/caseykuhlman@gmail.com $EXTERNAL_HD/GDocs
rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/Insync/caseykuhlman@watershedlegal.com $EXTERNAL_HD/GDocs
rsync -rtpovclHzs --progress --delete --ignore-existing $BASIS/sites/ $EXTERNAL_HD/Coding
rsync -rtpovclHzs --progress --delete --ignore-existing $EXTERNAL_HD/Photos $GANDI_DRIVE
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#75715e"># STEP 3 - NOTIFICATIONS&lt;/span>
&lt;span style="color:#75715e">## REDACTED&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>The script is fairly straight forward. The first section of the script simply sets up defaults which I can use throughout the rest of the script. The second section then checks if Watershed's cloud server is available and if so, it rsync's the designated folders into the server. rsync has an absolute ton of options which allow it to do a great variety of things. If you want to understand what each of the switches I have set up do (switches mean the &lt;code>-rtpovclHzs --progress --delete --ignore-existing&lt;/code> portion of the script) then simply go to your terminal and type &lt;code>man rsync&lt;/code>. If you are too lazy to read all of the man page &amp;ndash; and I don't blame you because it is long and I've been working through this for a while now, then you can simply copy the switches and know that they will make a mirror online of the current state of your data. This is not a backup setup, it is a mirroring setup. The major difference between the two being if you delete something locally it will be deleted on the remote server. If that is not what you want then you would simply delete the &lt;code>--delete&lt;/code> switch.&lt;/p>
&lt;p>There is one minor gotcha with rsync. If you look at the difference between the last two rsync calls within the &lt;code>Step 2&lt;/code> section you should see a very small difference. What is different is that in the final call there is a slash at the end of the reference which does not exist in the previous one, in other words the difference is &lt;code>$BASIS/sites/&lt;/code> and &lt;code>$BASIS/Insync/caseykuhlman@watershedlegal.com&lt;/code>. To rysnc the latter means to copy the directory (and anything inside of it based on the &lt;code>-r&lt;/code> switch earlier in the command) so that there will be a &lt;code>caseykuhlman@watershedlegal.com&lt;/code> directory within the destination. To rsync the former means to copy everything inside of the directory so that there will not be a &lt;code>sites&lt;/code> folder inside the destination.&lt;/p>
&lt;p>The last major thing that I have on the script is a notification system which sends me a &lt;a href="https://pushover.net">Pushover&lt;/a> alert whenever the script has run. Since I run the script each night, if I do not wake up to a notification then I know that it has not run. I have yet to not have that happen except for when my computer is off or I'm in transit but usually it is fine as everything will get backed up the next day. The notifications tell me whether it has backed up to the onsite external and/or the server so I quickly can tell what has happened.&lt;/p>
&lt;h2 id="automating-rsync-with-cron">Automating rsync with cron&lt;/h2>
&lt;p>Cron jobs are amazing. This will be quite quick as it is very very straight forward. The script I showed above is saved as ~/.bin/backupjobs. (Note after you save a script do not forget to make it executable by running &lt;code>chmod +x&lt;/code> on your system.) Then all I have to do is add the following line to my crontab by running &lt;code>crontab -e&lt;/code> (for edit) from my terminal&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#ae81ff">42&lt;/span> &lt;span style="color:#ae81ff">03&lt;/span> * * * /home/coda/.bin/backupjobs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Cron is a bit confusing at first, but here is what is happening. The first field is the minutes, so this job is to run at 42 minutes. The second field is the hours, so this job is to run at 03 hours, or 0342. The third field is the day of the month (in other words if you wanted to run monthly jobs you would set this to run on a particular day of the month &amp;ndash; maybe the 1st or the 15th or whatever), the * in the field means every day of the month. The next field is the month of the year, so this job is to run every month of the year and every day of the month. The final field is the day of the week. So the last three fields having a * means that the script should run at 0342 every day. The final portion is simply the script that the cronjob is supposed to run.&lt;/p>
&lt;p>That's it. Now everything is automated. I save files in my Dropbox or Google Drive or other folders during the day and at night my rsync and cron jobs back those up automatically to my onsite external and Watershed's servers. Voila. Completely automated, nuclear attack (but not nuclear annihilation) proof system.&lt;/p>
&lt;p>Happy Hacking!&lt;/p>
&lt;p>~ # ~&lt;/p></description></item><item><title>Autostarting Different Programs in Different Desktops</title><link>https://caseykuhlman.com/muniments/2013/2013-04-12-autostarting-for-different-linux-desktops/</link><pubDate>Fri, 12 Apr 2013 00:00:00 +0000</pubDate><author>casey@caseykuhlman.com (Casey Kuhlman)</author><guid>https://caseykuhlman.com/muniments/2013/2013-04-12-autostarting-for-different-linux-desktops/</guid><description>&lt;p>One of the most obvious appeals of Linux to me is the insane levels of customization you can achieve. I mainly use Gnome Shell as my desktop environment, but since I use Ubuntu I keep Unity on my machine. I'm not a hater of Unity or Gnome as many Linux users (who can be quite vitriolic in their statements as to desktop environments). I &lt;em>mostly&lt;/em> use Gnome, but since Ubuntu has some interesting things going on with Unity sometimes I like to drop into Unity to see what I'm missing.&lt;/p>
&lt;p>There is a problem at least in Ubuntu 12.10 running both desktops. To use Gnome Shell one &lt;em>should&lt;/em> install the &lt;code>gdm&lt;/code> package in order to get the full Gnome desktop experience - including the Gnome lock screen which is beautiful. GDM stands for Gnome Desktop Manager. It is an alternative to &lt;code>lightdm&lt;/code> which Ubuntu installs by default and which Unity uses. When you switch to gdm I found out that just after installing it you should logout of Unity before restarting your machine. But I didn't do that.&lt;/p>
&lt;p>The result of installing gdm and then restarting your machine is that the X server (which runs most of the linux desktops and lies in the stack underneath both gdm and lightdm) doesn't start correctly for &amp;ldquo;both&amp;rdquo; Unity and Shell. It is something to do with the way that dm loads the XSessions and it is beyond my understanding. In any event the problem for me was that while gdm made Shell work as it should out of the box, Unity would not load when I logged into Unity desktop.&lt;/p>
&lt;p>So I built a small autostart script that for Unity that will load Unity after logging into the Ubuntu desktop. This was straight-forward. But the problem I had is that I didn't want the script to try to load Unity when I logged into Gnome. But, as usual with linux, with a bit of Googling I came across the key. In X session desktop scripts (which are the main way to start/run programs) you can define which desktop environment they should show up in. This means that when you put the script into the autostart folder (~/.config/autostart) you can mark the script to &amp;hellip; &lt;code>OnlyShowIn=GNOME;&lt;/code> or &lt;code>OnlyShowIn=UNITY;&lt;/code> or &lt;code>NotShowIn=GNOME;&lt;/code> or &lt;code>NotShowIn=UNITY;&lt;/code>. You can add multiple environments for the desktop script to be shown or hidden in after the semicolons.&lt;/p>
&lt;p>This is helpful for showing or hiding certain programs/scripts in your menus in different desktop environments but also when you put it in the scripts in your autostart folder you can tell linux to only load the programs when you log into certain desktop environments. I tested the script and it didn't work at first. The problem was because gdm wasn't loading Unity, the autoload scripts I marked to only load in Unity weren't triggering. Even though gdm sent me to Unity, the desktop environment wasn't loading correctly. So I had to change the script from &lt;code>OnlyShowIn=UNITY;&lt;/code> to &lt;code>NotShowIn=GNOME;&lt;/code>. This meant that when the desktop environment saw that it was not in Shell it triggered the script for Unity. It isn't ideal as the autoload scripts that are linked to Unity don't run &lt;em>after&lt;/em> the Unity reload script runs, but it is a decent enough work around for the amount that I use Unity (minimal).&lt;/p>
&lt;p>This is very powerful as you usually want Gnome Shell and Unity to load the different sugar packages such as applets, indicators, etc., that help you define the environment you are working in. This is reason 7 million why Linux is awesome. In any event, here's the script I use to reload the Unity desktop after I log into Unity.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>Desktop Entry&lt;span style="color:#f92672">]&lt;/span>
Type&lt;span style="color:#f92672">=&lt;/span>Application
Exec&lt;span style="color:#f92672">=&lt;/span>unity
Hidden&lt;span style="color:#f92672">=&lt;/span>false
NoDisplay&lt;span style="color:#f92672">=&lt;/span>false
X-GNOME-Autostart-enabled&lt;span style="color:#f92672">=&lt;/span>true
Name&lt;span style="color:#f92672">=&lt;/span>Unity-Reset
NotShowIn&lt;span style="color:#f92672">=&lt;/span>GNOME;&lt;/code>&lt;/pre>&lt;/div>
&lt;p>I saved that in ~/.config/autostart and voila all (mostly) working as it should.&lt;/p>
&lt;p>Happy Hacking!&lt;/p>
&lt;p>~ # ~&lt;/p></description></item></channel></rss>